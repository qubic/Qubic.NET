@page "/tools/crypto"

<h4>Crypto Toolkit</h4>
<p class="text-muted">Offline cryptographic utilities: seed generation, K12 hash, sign/verify messages, identity conversions.</p>

<div class="row g-3">
    <div class="col-md-6">
        <div class="card">
            <div class="card-header">Seed Generator</div>
            <div class="card-body">
                <p class="small text-muted mb-2">Generate a cryptographically secure random seed (55 lowercase letters).</p>
                <button class="btn btn-sm btn-primary" @onclick="GenerateSeed">Generate Seed</button>
                @if (_genSeed != null)
                {
                    <div class="mt-2">
                        <label class="form-label-sm">Seed</label>
                        <div class="input-group input-group-sm">
                            <input type="@(_genSeedVisible ? "text" : "password")" class="form-control form-control-sm mono"
                                   value="@_genSeed" readonly />
                            <button class="btn btn-outline-secondary" @onclick="() => _genSeedVisible = !_genSeedVisible"
                                    title="@(_genSeedVisible ? "Hide" : "Show")">
                                @(_genSeedVisible ? "Hide" : "Show")
                            </button>
                        </div>
                    </div>
                    <div class="mt-2">
                        <label class="form-label-sm">Identity</label>
                        <input class="form-control form-control-sm mono" value="@_genIdentity" readonly />
                    </div>
                    <div class="mt-2">
                        <label class="form-label-sm">Public Key</label>
                        <input class="form-control form-control-sm mono" value="@_genPubKeyHex" readonly />
                    </div>
                    <div class="alert alert-warning small mt-2 mb-0 py-1 px-2">
                        Save this seed securely. It cannot be recovered.
                    </div>
                }
                @if (_genError != null)
                {
                    <div class="text-danger small mt-1">@_genError</div>
                }
            </div>
        </div>
    </div>

    <div class="col-md-6">
        <div class="card">
            <div class="card-header">K12 Hash</div>
            <div class="card-body">
                <div class="mb-2">
                    <label class="form-label-sm">Input (hex)</label>
                    <textarea class="form-control form-control-sm mono" rows="2" @bind="_hashInput"></textarea>
                </div>
                <button class="btn btn-sm btn-primary" @onclick="ComputeHash">Hash</button>
                @if (_hashResult != null)
                {
                    <div class="mt-2">
                        <label class="form-label-sm">K12 (32 bytes)</label>
                        <input class="form-control form-control-sm mono" value="@_hashResult" readonly />
                    </div>
                }
                @if (_hashError != null)
                {
                    <div class="text-danger small mt-1">@_hashError</div>
                }
            </div>
        </div>
    </div>

    <div class="col-md-6">
        <div class="card">
            <div class="card-header">Sign Message</div>
            <div class="card-body">
                <div class="mb-2">
                    <label class="form-label-sm">Seed (55 chars)</label>
                    <input type="password" class="form-control form-control-sm" @bind="_signSeed" />
                </div>
                <div class="mb-2">
                    <label class="form-label-sm">Message (hex)</label>
                    <textarea class="form-control form-control-sm mono" rows="2" @bind="_signMessage"></textarea>
                </div>
                <button class="btn btn-sm btn-primary" @onclick="SignMessage">Sign</button>
                @if (_signResult != null)
                {
                    <div class="mt-2">
                        <label class="form-label-sm">Signature (64 bytes)</label>
                        <textarea class="form-control form-control-sm mono" rows="2" readonly>@_signResult</textarea>
                    </div>
                }
                @if (_signError != null)
                {
                    <div class="text-danger small mt-1">@_signError</div>
                }
            </div>
        </div>
    </div>

    <div class="col-md-6">
        <div class="card">
            <div class="card-header">Verify Signature</div>
            <div class="card-body">
                <div class="mb-2">
                    <label class="form-label-sm">Public Key (64 hex) or Identity (60 chars)</label>
                    <input class="form-control form-control-sm mono" @bind="_verifyPubKey" />
                </div>
                <div class="mb-2">
                    <label class="form-label-sm">Message (hex)</label>
                    <textarea class="form-control form-control-sm mono" rows="2" @bind="_verifyMessage"></textarea>
                </div>
                <div class="mb-2">
                    <label class="form-label-sm">Signature (128 hex)</label>
                    <textarea class="form-control form-control-sm mono" rows="2" @bind="_verifySignature"></textarea>
                </div>
                <button class="btn btn-sm btn-primary" @onclick="VerifySignature">Verify</button>
                @if (_verifyResult != null)
                {
                    <span class="ms-2 badge @(_verifyResult == true ? "bg-success" : "bg-danger")">
                        @(_verifyResult == true ? "Valid" : "Invalid")
                    </span>
                }
                @if (_verifyError != null)
                {
                    <div class="text-danger small mt-1">@_verifyError</div>
                }
            </div>
        </div>
    </div>

    <div class="col-md-6">
        <div class="card">
            <div class="card-header">Identity / Public Key Converter</div>
            <div class="card-body">
                <div class="mb-2">
                    <label class="form-label-sm">Identity (60 chars) or Public Key (64 hex)</label>
                    <input class="form-control form-control-sm mono" @bind="_convertInput"
                           @bind:event="oninput" @bind:after="OnConvertChanged" />
                </div>
                @if (_convertIdentity != null)
                {
                    <table class="table table-sm mb-0">
                        <tr><td class="text-muted">Identity</td><td class="mono">@_convertIdentity</td></tr>
                        <tr><td class="text-muted">Public Key</td><td class="mono">@_convertPubKeyHex</td></tr>
                    </table>
                }
                @if (_convertError != null)
                {
                    <div class="text-danger small mt-1">@_convertError</div>
                }
            </div>
        </div>
    </div>
</div>

@code {
    private readonly Qubic.Crypto.QubicCrypt _crypt = new();

    // Seed Generator
    private string? _genSeed;
    private string? _genIdentity;
    private string? _genPubKeyHex;
    private bool _genSeedVisible;
    private string? _genError;

    // K12 Hash
    private string? _hashInput;
    private string? _hashResult;
    private string? _hashError;

    // Sign
    private string? _signSeed;
    private string? _signMessage;
    private string? _signResult;
    private string? _signError;

    // Verify
    private string? _verifyPubKey;
    private string? _verifyMessage;
    private string? _verifySignature;
    private bool? _verifyResult;
    private string? _verifyError;

    // Convert
    private string? _convertInput;
    private string? _convertIdentity;
    private string? _convertPubKeyHex;
    private string? _convertError;

    private void GenerateSeed()
    {
        _genSeed = null;
        _genIdentity = null;
        _genPubKeyHex = null;
        _genError = null;
        try
        {
            var randomBytes = new byte[55];
            System.Security.Cryptography.RandomNumberGenerator.Fill(randomBytes);
            var chars = new char[55];
            for (int i = 0; i < 55; i++)
                chars[i] = (char)('a' + (randomBytes[i] % 26));
            _genSeed = new string(chars);
            _genSeedVisible = false;

            var pubKey = _crypt.GetPublicKey(_genSeed);
            var identity = Qubic.Core.Entities.QubicIdentity.FromPublicKey(pubKey);
            _genIdentity = identity.ToString();
            _genPubKeyHex = Convert.ToHexString(pubKey).ToLowerInvariant();
        }
        catch (Exception ex) { _genError = ex.Message; }
    }

    private void ComputeHash()
    {
        _hashResult = null;
        _hashError = null;
        try
        {
            var input = string.IsNullOrWhiteSpace(_hashInput) ? [] : Convert.FromHexString(_hashInput.Trim());
            var hash = _crypt.KangarooTwelve(input, 32);
            _hashResult = Convert.ToHexString(hash).ToLowerInvariant();
        }
        catch (Exception ex) { _hashError = ex.Message; }
    }

    private void SignMessage()
    {
        _signResult = null;
        _signError = null;
        try
        {
            if (string.IsNullOrWhiteSpace(_signSeed) || _signSeed.Length != 55)
            {
                _signError = "Seed must be 55 characters.";
                return;
            }
            var message = string.IsNullOrWhiteSpace(_signMessage) ? [] : Convert.FromHexString(_signMessage.Trim());
            var signed = _crypt.Sign(_signSeed, message);
            var sig = new byte[64];
            Array.Copy(signed, signed.Length - 64, sig, 0, 64);
            _signResult = Convert.ToHexString(sig).ToLowerInvariant();
        }
        catch (Exception ex) { _signError = ex.Message; }
    }

    private void VerifySignature()
    {
        _verifyResult = null;
        _verifyError = null;
        try
        {
            if (string.IsNullOrWhiteSpace(_verifyPubKey))
            {
                _verifyError = "Public key or identity is required.";
                return;
            }
            if (string.IsNullOrWhiteSpace(_verifySignature))
            {
                _verifyError = "Signature is required.";
                return;
            }

            byte[] pubKey;
            var pkInput = _verifyPubKey.Trim();
            if (pkInput.Length == 60 && pkInput.All(c => c >= 'A' && c <= 'Z'))
                pubKey = Qubic.Core.Entities.QubicIdentity.FromIdentity(pkInput).PublicKey;
            else
                pubKey = Convert.FromHexString(pkInput);

            var message = string.IsNullOrWhiteSpace(_verifyMessage) ? [] : Convert.FromHexString(_verifyMessage.Trim());
            var signature = Convert.FromHexString(_verifySignature.Trim());

            _verifyResult = _crypt.Verify(pubKey, message, signature);
        }
        catch (Exception ex) { _verifyError = ex.Message; }
    }

    private void OnConvertChanged()
    {
        _convertIdentity = null;
        _convertPubKeyHex = null;
        _convertError = null;
        if (string.IsNullOrWhiteSpace(_convertInput)) return;

        var input = _convertInput.Trim();
        try
        {
            if (input.Length == 60 && input.All(c => c >= 'A' && c <= 'Z'))
            {
                var id = Qubic.Core.Entities.QubicIdentity.FromIdentity(input);
                _convertIdentity = id.ToString();
                _convertPubKeyHex = Convert.ToHexString(id.PublicKey).ToLowerInvariant();
            }
            else if (input.Length == 64 && input.All(c => "0123456789abcdefABCDEF".Contains(c)))
            {
                var pubKey = Convert.FromHexString(input);
                var id = Qubic.Core.Entities.QubicIdentity.FromPublicKey(pubKey);
                _convertIdentity = id.ToString();
                _convertPubKeyHex = Convert.ToHexString(pubKey).ToLowerInvariant();
            }
        }
        catch (Exception ex) { _convertError = ex.Message; }
    }
}
