// <auto-generated>
// Generated by Qubic.ContractGen from QReservePool.h.
// Do not edit manually. Re-run the generator after updating deps/qubic-core.
// </auto-generated>

using System.Buffers.Binary;
using Qubic.Core.Contracts;
using Qubic.Core.Payloads;

namespace Qubic.Core.Contracts.Qrp;

/// <summary>Qrp contract (index 21).</summary>
public static class QrpContract
{
    /// <summary>Contract index on the Qubic network.</summary>
    public const int ContractIndex = 21;

    /// <summary>Gets the 32-byte contract public key.</summary>
    public static byte[] GetPublicKey() => QubicContracts.GetContractPublicKey(ContractIndex);

    /// <summary>Read-only query function IDs.</summary>
    public static class Functions
    {
        /// <summary>GetAvailableReserve (inputType=1).</summary>
        public const uint GetAvailableReserve = 1;
        /// <summary>GetAllowedSC (inputType=2).</summary>
        public const uint GetAllowedSC = 2;
    }

    /// <summary>State-mutating procedure IDs.</summary>
    public static class Procedures
    {
        /// <summary>WithdrawReserve (inputType=1).</summary>
        public const uint WithdrawReserve = 1;
        /// <summary>AddAllowedSC (inputType=2).</summary>
        public const uint AddAllowedSC = 2;
        /// <summary>RemoveAllowedSC (inputType=3).</summary>
        public const uint RemoveAllowedSC = 3;
        /// <summary>SendReserve (inputType=4).</summary>
        public const uint SendReserve = 4;
    }
}

// ═══ Function: GetAvailableReserve (inputType=1) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetAvailableReserveInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetAvailableReserveOutput : ISmartContractOutput<GetAvailableReserveOutput>
{
    public ulong AvailableReserve { get; init; }

    public static GetAvailableReserveOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetAvailableReserveOutput
        {
            AvailableReserve = BinaryPrimitives.ReadUInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Function: GetAllowedSC (inputType=2) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetAllowedSCInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetAllowedSCOutput : ISmartContractOutput<GetAllowedSCOutput>
{
    public byte[][] AllowedSC { get; init; }

    public static GetAllowedSCOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var allowedSC = new byte[0][];
        for (int i = 0; i < 0; i++)
        {
            allowedSC[i] = data[(0 + i * 32)..].Slice(0, 32).ToArray();
        }
        return new GetAllowedSCOutput
        {
            AllowedSC = allowedSC
        };
    }
}

// ═══ Procedure: WithdrawReserve (inputType=1) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class WithdrawReservePayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 8;

    public ushort InputType => 1;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public ulong Revenue { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), Revenue);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct WithdrawReserveOutput : ISmartContractOutput<WithdrawReserveOutput>
{
    public ulong AllocatedRevenue { get; init; }
    public byte ReturnCode { get; init; }

    public static WithdrawReserveOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new WithdrawReserveOutput
        {
            AllocatedRevenue = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            ReturnCode = data.Slice(8, 1)[0]
        };
    }
}

// ═══ Procedure: AddAllowedSC (inputType=2) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class AddAllowedSCPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 8;

    public ushort InputType => 2;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public ulong ScIndex { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), ScIndex);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct AddAllowedSCOutput : ISmartContractOutput<AddAllowedSCOutput>
{
    public byte ReturnCode { get; init; }

    public static AddAllowedSCOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new AddAllowedSCOutput
        {
            ReturnCode = data.Slice(0, 1)[0]
        };
    }
}

// ═══ Procedure: RemoveAllowedSC (inputType=3) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class RemoveAllowedSCPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 8;

    public ushort InputType => 3;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public ulong ScIndex { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), ScIndex);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct RemoveAllowedSCOutput : ISmartContractOutput<RemoveAllowedSCOutput>
{
    public byte ReturnCode { get; init; }

    public static RemoveAllowedSCOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new RemoveAllowedSCOutput
        {
            ReturnCode = data.Slice(0, 1)[0]
        };
    }
}

// ═══ Procedure: SendReserve (inputType=4) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class SendReservePayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 16;

    public ushort InputType => 4;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public ulong ScIndex { get; init; }
    public ulong Amount { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), ScIndex);
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(8), Amount);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct SendReserveOutput : ISmartContractOutput<SendReserveOutput>
{
    public byte ReturnCode { get; init; }

    public static SendReserveOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new SendReserveOutput
        {
            ReturnCode = data.Slice(0, 1)[0]
        };
    }
}
