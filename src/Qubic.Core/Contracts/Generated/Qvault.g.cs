// <auto-generated>
// Generated by Qubic.ContractGen from QVAULT.h.
// Do not edit manually. Re-run the generator after updating deps/qubic-core.
// </auto-generated>

using System.Buffers.Binary;
using Qubic.Core.Contracts;
using Qubic.Core.Payloads;

namespace Qubic.Core.Contracts.Qvault;

/// <summary>Qvault contract (index 10).</summary>
public static class QvaultContract
{
    /// <summary>Contract index on the Qubic network.</summary>
    public const int ContractIndex = 10;

    /// <summary>Gets the 32-byte contract public key.</summary>
    public static byte[] GetPublicKey() => QubicContracts.GetContractPublicKey(ContractIndex);

    /// <summary>Read-only query function IDs.</summary>
    public static class Functions
    {
        /// <summary>getData (inputType=1).</summary>
        public const uint GetData = 1;
    }

    /// <summary>State-mutating procedure IDs.</summary>
    public static class Procedures
    {
        /// <summary>submitAuthAddress (inputType=1).</summary>
        public const uint SubmitAuthAddress = 1;
        /// <summary>changeAuthAddress (inputType=2).</summary>
        public const uint ChangeAuthAddress = 2;
        /// <summary>submitDistributionPermille (inputType=3).</summary>
        public const uint SubmitDistributionPermille = 3;
        /// <summary>changeDistributionPermille (inputType=4).</summary>
        public const uint ChangeDistributionPermille = 4;
        /// <summary>submitReinvestingAddress (inputType=5).</summary>
        public const uint SubmitReinvestingAddress = 5;
        /// <summary>changeReinvestingAddress (inputType=6).</summary>
        public const uint ChangeReinvestingAddress = 6;
        /// <summary>submitAdminAddress (inputType=7).</summary>
        public const uint SubmitAdminAddress = 7;
        /// <summary>changeAdminAddress (inputType=8).</summary>
        public const uint ChangeAdminAddress = 8;
        /// <summary>submitBannedAddress (inputType=9).</summary>
        public const uint SubmitBannedAddress = 9;
        /// <summary>saveBannedAddress (inputType=10).</summary>
        public const uint SaveBannedAddress = 10;
        /// <summary>submitUnbannedAddress (inputType=11).</summary>
        public const uint SubmitUnbannedAddress = 11;
        /// <summary>unblockBannedAddress (inputType=12).</summary>
        public const uint UnblockBannedAddress = 12;
    }
}

// ═══ Function: getData (inputType=1) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetDataInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetDataOutput : ISmartContractOutput<GetDataOutput>
{
    public ulong NumberOfBannedAddress { get; init; }
    public uint ShareholderDividend { get; init; }
    public uint QCAPHolderPermille { get; init; }
    public uint ReinvestingPermille { get; init; }
    public uint DevPermille { get; init; }
    public byte[] AuthAddress1 { get; init; }
    public byte[] AuthAddress2 { get; init; }
    public byte[] AuthAddress3 { get; init; }
    public byte[] ReinvestingAddress { get; init; }
    public byte[] AdminAddress { get; init; }
    public byte[] NewAuthAddress1 { get; init; }
    public byte[] NewAuthAddress2 { get; init; }
    public byte[] NewAuthAddress3 { get; init; }
    public byte[] NewReinvestingAddress1 { get; init; }
    public byte[] NewReinvestingAddress2 { get; init; }
    public byte[] NewReinvestingAddress3 { get; init; }
    public byte[] NewAdminAddress1 { get; init; }
    public byte[] NewAdminAddress2 { get; init; }
    public byte[] NewAdminAddress3 { get; init; }
    public byte[] BannedAddress1 { get; init; }
    public byte[] BannedAddress2 { get; init; }
    public byte[] BannedAddress3 { get; init; }
    public byte[] UnbannedAddress1 { get; init; }
    public byte[] UnbannedAddress2 { get; init; }
    public byte[] UnbannedAddress3 { get; init; }

    public static GetDataOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetDataOutput
        {
            NumberOfBannedAddress = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            ShareholderDividend = BinaryPrimitives.ReadUInt32LittleEndian(data[8..]),
            QCAPHolderPermille = BinaryPrimitives.ReadUInt32LittleEndian(data[12..]),
            ReinvestingPermille = BinaryPrimitives.ReadUInt32LittleEndian(data[16..]),
            DevPermille = BinaryPrimitives.ReadUInt32LittleEndian(data[20..]),
            AuthAddress1 = data[24..].Slice(0, 32).ToArray(),
            AuthAddress2 = data[56..].Slice(0, 32).ToArray(),
            AuthAddress3 = data[88..].Slice(0, 32).ToArray(),
            ReinvestingAddress = data[120..].Slice(0, 32).ToArray(),
            AdminAddress = data[152..].Slice(0, 32).ToArray(),
            NewAuthAddress1 = data[184..].Slice(0, 32).ToArray(),
            NewAuthAddress2 = data[216..].Slice(0, 32).ToArray(),
            NewAuthAddress3 = data[248..].Slice(0, 32).ToArray(),
            NewReinvestingAddress1 = data[280..].Slice(0, 32).ToArray(),
            NewReinvestingAddress2 = data[312..].Slice(0, 32).ToArray(),
            NewReinvestingAddress3 = data[344..].Slice(0, 32).ToArray(),
            NewAdminAddress1 = data[376..].Slice(0, 32).ToArray(),
            NewAdminAddress2 = data[408..].Slice(0, 32).ToArray(),
            NewAdminAddress3 = data[440..].Slice(0, 32).ToArray(),
            BannedAddress1 = data[472..].Slice(0, 32).ToArray(),
            BannedAddress2 = data[504..].Slice(0, 32).ToArray(),
            BannedAddress3 = data[536..].Slice(0, 32).ToArray(),
            UnbannedAddress1 = data[568..].Slice(0, 32).ToArray(),
            UnbannedAddress2 = data[600..].Slice(0, 32).ToArray(),
            UnbannedAddress3 = data[632..].Slice(0, 32).ToArray()
        };
    }
}

// ═══ Procedure: submitAuthAddress (inputType=1) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class SubmitAuthAddressPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 32;

    public ushort InputType => 1;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] NewAddress { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        NewAddress.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        return bytes;
    }
}

/// <summary>Output (empty).</summary>
public readonly struct SubmitAuthAddressOutput : ISmartContractOutput<SubmitAuthAddressOutput>
{
    public static SubmitAuthAddressOutput FromBytes(ReadOnlySpan<byte> data) => new();
}

// ═══ Procedure: changeAuthAddress (inputType=2) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class ChangeAuthAddressPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 4;

    public ushort InputType => 2;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public uint NumberOfChangedAddress { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), NumberOfChangedAddress);
        return bytes;
    }
}

/// <summary>Output (empty).</summary>
public readonly struct ChangeAuthAddressOutput : ISmartContractOutput<ChangeAuthAddressOutput>
{
    public static ChangeAuthAddressOutput FromBytes(ReadOnlySpan<byte> data) => new();
}

// ═══ Procedure: submitDistributionPermille (inputType=3) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class SubmitDistributionPermillePayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 12;

    public ushort InputType => 3;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public uint NewQCAPHolderPermille { get; init; }
    public uint NewReinvestingPermille { get; init; }
    public uint NewDevPermille { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), NewQCAPHolderPermille);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(4), NewReinvestingPermille);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(8), NewDevPermille);
        return bytes;
    }
}

/// <summary>Output (empty).</summary>
public readonly struct SubmitDistributionPermilleOutput : ISmartContractOutput<SubmitDistributionPermilleOutput>
{
    public static SubmitDistributionPermilleOutput FromBytes(ReadOnlySpan<byte> data) => new();
}

// ═══ Procedure: changeDistributionPermille (inputType=4) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class ChangeDistributionPermillePayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 12;

    public ushort InputType => 4;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public uint NewQCAPHolderPermille { get; init; }
    public uint NewReinvestingPermille { get; init; }
    public uint NewDevPermille { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), NewQCAPHolderPermille);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(4), NewReinvestingPermille);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(8), NewDevPermille);
        return bytes;
    }
}

/// <summary>Output (empty).</summary>
public readonly struct ChangeDistributionPermilleOutput : ISmartContractOutput<ChangeDistributionPermilleOutput>
{
    public static ChangeDistributionPermilleOutput FromBytes(ReadOnlySpan<byte> data) => new();
}

// ═══ Procedure: submitReinvestingAddress (inputType=5) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class SubmitReinvestingAddressPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 32;

    public ushort InputType => 5;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] NewAddress { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        NewAddress.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        return bytes;
    }
}

/// <summary>Output (empty).</summary>
public readonly struct SubmitReinvestingAddressOutput : ISmartContractOutput<SubmitReinvestingAddressOutput>
{
    public static SubmitReinvestingAddressOutput FromBytes(ReadOnlySpan<byte> data) => new();
}

// ═══ Procedure: changeReinvestingAddress (inputType=6) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class ChangeReinvestingAddressPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 32;

    public ushort InputType => 6;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] NewAddress { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        NewAddress.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        return bytes;
    }
}

/// <summary>Output (empty).</summary>
public readonly struct ChangeReinvestingAddressOutput : ISmartContractOutput<ChangeReinvestingAddressOutput>
{
    public static ChangeReinvestingAddressOutput FromBytes(ReadOnlySpan<byte> data) => new();
}

// ═══ Procedure: submitAdminAddress (inputType=7) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class SubmitAdminAddressPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 32;

    public ushort InputType => 7;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] NewAddress { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        NewAddress.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        return bytes;
    }
}

/// <summary>Output (empty).</summary>
public readonly struct SubmitAdminAddressOutput : ISmartContractOutput<SubmitAdminAddressOutput>
{
    public static SubmitAdminAddressOutput FromBytes(ReadOnlySpan<byte> data) => new();
}

// ═══ Procedure: changeAdminAddress (inputType=8) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class ChangeAdminAddressPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 32;

    public ushort InputType => 8;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] NewAddress { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        NewAddress.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        return bytes;
    }
}

/// <summary>Output (empty).</summary>
public readonly struct ChangeAdminAddressOutput : ISmartContractOutput<ChangeAdminAddressOutput>
{
    public static ChangeAdminAddressOutput FromBytes(ReadOnlySpan<byte> data) => new();
}

// ═══ Procedure: submitBannedAddress (inputType=9) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class SubmitBannedAddressPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 32;

    public ushort InputType => 9;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] BannedAddress { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BannedAddress.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        return bytes;
    }
}

/// <summary>Output (empty).</summary>
public readonly struct SubmitBannedAddressOutput : ISmartContractOutput<SubmitBannedAddressOutput>
{
    public static SubmitBannedAddressOutput FromBytes(ReadOnlySpan<byte> data) => new();
}

// ═══ Procedure: saveBannedAddress (inputType=10) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class SaveBannedAddressPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 32;

    public ushort InputType => 10;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] BannedAddress { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BannedAddress.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        return bytes;
    }
}

/// <summary>Output (empty).</summary>
public readonly struct SaveBannedAddressOutput : ISmartContractOutput<SaveBannedAddressOutput>
{
    public static SaveBannedAddressOutput FromBytes(ReadOnlySpan<byte> data) => new();
}

// ═══ Procedure: submitUnbannedAddress (inputType=11) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class SubmitUnbannedAddressPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 32;

    public ushort InputType => 11;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] UnbannedAddress { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        UnbannedAddress.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        return bytes;
    }
}

/// <summary>Output (empty).</summary>
public readonly struct SubmitUnbannedAddressOutput : ISmartContractOutput<SubmitUnbannedAddressOutput>
{
    public static SubmitUnbannedAddressOutput FromBytes(ReadOnlySpan<byte> data) => new();
}

// ═══ Procedure: unblockBannedAddress (inputType=12) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class UnblockBannedAddressPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 32;

    public ushort InputType => 12;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] UnbannedAddress { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        UnbannedAddress.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        return bytes;
    }
}

/// <summary>Output (empty).</summary>
public readonly struct UnblockBannedAddressOutput : ISmartContractOutput<UnblockBannedAddressOutput>
{
    public static UnblockBannedAddressOutput FromBytes(ReadOnlySpan<byte> data) => new();
}
