// <auto-generated>
// Generated by Qubic.ContractGen from Qdraw.h.
// Do not edit manually. Re-run the generator after updating deps/qubic-core.
// </auto-generated>

using System.Buffers.Binary;
using Qubic.Core.Contracts;
using Qubic.Core.Payloads;

namespace Qubic.Core.Contracts.Qdraw;

/// <summary>Qdraw contract (index 15).</summary>
public static class QdrawContract
{
    /// <summary>Contract index on the Qubic network.</summary>
    public const int ContractIndex = 15;

    /// <summary>Gets the 32-byte contract public key.</summary>
    public static byte[] GetPublicKey() => QubicContracts.GetContractPublicKey(ContractIndex);

    /// <summary>Read-only query function IDs.</summary>
    public static class Functions
    {
        /// <summary>getInfo (inputType=2).</summary>
        public const uint GetInfo = 2;
        /// <summary>getParticipants (inputType=3).</summary>
        public const uint GetParticipants = 3;
    }

    /// <summary>State-mutating procedure IDs.</summary>
    public static class Procedures
    {
        /// <summary>buyTicket (inputType=1).</summary>
        public const uint BuyTicket = 1;
    }
}

// ═══ Function: getInfo (inputType=2) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetInfoInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetInfoOutput : ISmartContractOutput<GetInfoOutput>
{
    public long Pot { get; init; }
    public ulong ParticipantCount { get; init; }
    public byte[] LastWinner { get; init; }
    public long LastWinAmount { get; init; }
    public byte LastDrawHour { get; init; }
    public byte CurrentHour { get; init; }
    public byte NextDrawHour { get; init; }

    public static GetInfoOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetInfoOutput
        {
            Pot = BinaryPrimitives.ReadInt64LittleEndian(data[0..]),
            ParticipantCount = BinaryPrimitives.ReadUInt64LittleEndian(data[8..]),
            LastWinner = data[16..].Slice(0, 32).ToArray(),
            LastWinAmount = BinaryPrimitives.ReadInt64LittleEndian(data[48..]),
            LastDrawHour = data.Slice(56, 1)[0],
            CurrentHour = data.Slice(57, 1)[0],
            NextDrawHour = data.Slice(58, 1)[0]
        };
    }
}

// ═══ Function: getParticipants (inputType=3) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetParticipantsInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetParticipantsOutput : ISmartContractOutput<GetParticipantsOutput>
{
    public ulong ParticipantCount { get; init; }
    public ulong UniqueParticipantCount { get; init; }
    public byte[][] Participants { get; init; }
    public ulong[] TicketCounts { get; init; }

    public static GetParticipantsOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var participants = new byte[0][];
        for (int i = 0; i < 0; i++)
        {
            participants[i] = data[(16 + i * 32)..].Slice(0, 32).ToArray();
        }
        var ticketCounts = new ulong[0];
        for (int i = 0; i < 0; i++)
        {
            ticketCounts[i] = BinaryPrimitives.ReadUInt64LittleEndian(data[(16 + i * 8)..]);
        }
        return new GetParticipantsOutput
        {
            ParticipantCount = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            UniqueParticipantCount = BinaryPrimitives.ReadUInt64LittleEndian(data[8..]),
            Participants = participants,
            TicketCounts = ticketCounts
        };
    }
}

// ═══ Procedure: buyTicket (inputType=1) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class BuyTicketPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 8;

    public ushort InputType => 1;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public ulong TicketCount { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), TicketCount);
        return bytes;
    }
}

/// <summary>Output (empty).</summary>
public readonly struct BuyTicketOutput : ISmartContractOutput<BuyTicketOutput>
{
    public static BuyTicketOutput FromBytes(ReadOnlySpan<byte> data) => new();
}
