// <auto-generated>
// Generated by Qubic.ContractGen from QThirtyFour.h.
// Do not edit manually. Re-run the generator after updating deps/qubic-core.
// </auto-generated>

using System.Buffers.Binary;
using Qubic.Core.Contracts;
using Qubic.Core.Payloads;

namespace Qubic.Core.Contracts.Qtf;

/// <summary>Qtf contract (index 22).</summary>
public static class QtfContract
{
    /// <summary>Contract index on the Qubic network.</summary>
    public const int ContractIndex = 22;

    /// <summary>Gets the 32-byte contract public key.</summary>
    public static byte[] GetPublicKey() => QubicContracts.GetContractPublicKey(ContractIndex);

    /// <summary>Read-only query function IDs.</summary>
    public static class Functions
    {
        /// <summary>GetTicketPrice (inputType=1).</summary>
        public const uint GetTicketPrice = 1;
        /// <summary>GetNextEpochData (inputType=2).</summary>
        public const uint GetNextEpochData = 2;
        /// <summary>GetWinnerData (inputType=3).</summary>
        public const uint GetWinnerData = 3;
        /// <summary>GetPools (inputType=4).</summary>
        public const uint GetPools = 4;
        /// <summary>GetSchedule (inputType=5).</summary>
        public const uint GetSchedule = 5;
        /// <summary>GetDrawHour (inputType=6).</summary>
        public const uint GetDrawHour = 6;
        /// <summary>GetState (inputType=7).</summary>
        public const uint GetState = 7;
        /// <summary>GetFees (inputType=8).</summary>
        public const uint GetFees = 8;
        /// <summary>EstimatePrizePayouts (inputType=9).</summary>
        public const uint EstimatePrizePayouts = 9;
    }

    /// <summary>State-mutating procedure IDs.</summary>
    public static class Procedures
    {
        /// <summary>BuyTicket (inputType=1).</summary>
        public const uint BuyTicket = 1;
        /// <summary>SetPrice (inputType=2).</summary>
        public const uint SetPrice = 2;
        /// <summary>SetSchedule (inputType=3).</summary>
        public const uint SetSchedule = 3;
        /// <summary>SetTargetJackpot (inputType=4).</summary>
        public const uint SetTargetJackpot = 4;
        /// <summary>SetDrawHour (inputType=5).</summary>
        public const uint SetDrawHour = 5;
    }
}

// ═══ Function: GetTicketPrice (inputType=1) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetTicketPriceInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetTicketPriceOutput : ISmartContractOutput<GetTicketPriceOutput>
{
    public ulong TicketPrice { get; init; }

    public static GetTicketPriceOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetTicketPriceOutput
        {
            TicketPrice = BinaryPrimitives.ReadUInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Function: GetNextEpochData (inputType=2) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetNextEpochDataInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetNextEpochDataOutput : ISmartContractOutput<GetNextEpochDataOutput>
{
    public byte[] NextEpochData { get; init; }

    public static GetNextEpochDataOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetNextEpochDataOutput
        {
            NextEpochData = [] /* unknown type NextEpochData */
        };
    }
}

// ═══ Function: GetWinnerData (inputType=3) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetWinnerDataInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetWinnerDataOutput : ISmartContractOutput<GetWinnerDataOutput>
{
    public byte[] WinnerData { get; init; }

    public static GetWinnerDataOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetWinnerDataOutput
        {
            WinnerData = [] /* unknown type WinnerData */
        };
    }
}

// ═══ Function: GetPools (inputType=4) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetPoolsInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetPoolsOutput : ISmartContractOutput<GetPoolsOutput>
{
    public byte[] Pools { get; init; }

    public static GetPoolsOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetPoolsOutput
        {
            Pools = [] /* unknown type PoolsSnapshot */
        };
    }
}

// ═══ Function: GetSchedule (inputType=5) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetScheduleInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetScheduleOutput : ISmartContractOutput<GetScheduleOutput>
{
    public byte Schedule { get; init; }

    public static GetScheduleOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetScheduleOutput
        {
            Schedule = data.Slice(0, 1)[0]
        };
    }
}

// ═══ Function: GetDrawHour (inputType=6) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetDrawHourInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetDrawHourOutput : ISmartContractOutput<GetDrawHourOutput>
{
    public byte DrawHour { get; init; }

    public static GetDrawHourOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetDrawHourOutput
        {
            DrawHour = data.Slice(0, 1)[0]
        };
    }
}

// ═══ Function: GetState (inputType=7) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetStateInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetStateOutput : ISmartContractOutput<GetStateOutput>
{
    public byte CurrentState { get; init; }

    public static GetStateOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetStateOutput
        {
            CurrentState = data.Slice(0, 1)[0]
        };
    }
}

// ═══ Function: GetFees (inputType=8) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetFeesInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetFeesOutput : ISmartContractOutput<GetFeesOutput>
{
    public byte TeamFeePercent { get; init; }
    public byte DistributionFeePercent { get; init; }
    public byte WinnerFeePercent { get; init; }
    public byte BurnPercent { get; init; }
    public byte ReturnCode { get; init; }

    public static GetFeesOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetFeesOutput
        {
            TeamFeePercent = data.Slice(0, 1)[0],
            DistributionFeePercent = data.Slice(1, 1)[0],
            WinnerFeePercent = data.Slice(2, 1)[0],
            BurnPercent = data.Slice(3, 1)[0],
            ReturnCode = data.Slice(4, 1)[0]
        };
    }
}

// ═══ Function: EstimatePrizePayouts (inputType=9) ═══

/// <summary>Input for query.</summary>
public readonly struct EstimatePrizePayoutsInput : ISmartContractInput
{
    public const int Size = 16;

    public int SerializedSize => Size;

    public ulong K2WinnerCount { get; init; }
    public ulong K3WinnerCount { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), K2WinnerCount);
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(8), K3WinnerCount);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct EstimatePrizePayoutsOutput : ISmartContractOutput<EstimatePrizePayoutsOutput>
{
    public ulong K2PayoutPerWinner { get; init; }
    public ulong K3PayoutPerWinner { get; init; }
    public ulong K2MinFloor { get; init; }
    public ulong K3MinFloor { get; init; }
    public ulong PerWinnerCap { get; init; }
    public ulong TotalRevenue { get; init; }
    public ulong K2Pool { get; init; }
    public ulong K3Pool { get; init; }

    public static EstimatePrizePayoutsOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new EstimatePrizePayoutsOutput
        {
            K2PayoutPerWinner = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            K3PayoutPerWinner = BinaryPrimitives.ReadUInt64LittleEndian(data[8..]),
            K2MinFloor = BinaryPrimitives.ReadUInt64LittleEndian(data[16..]),
            K3MinFloor = BinaryPrimitives.ReadUInt64LittleEndian(data[24..]),
            PerWinnerCap = BinaryPrimitives.ReadUInt64LittleEndian(data[32..]),
            TotalRevenue = BinaryPrimitives.ReadUInt64LittleEndian(data[40..]),
            K2Pool = BinaryPrimitives.ReadUInt64LittleEndian(data[48..]),
            K3Pool = BinaryPrimitives.ReadUInt64LittleEndian(data[56..])
        };
    }
}

// ═══ Procedure: BuyTicket (inputType=1) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class BuyTicketPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 0;

    public ushort InputType => 1;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public byte[] RandomValues { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        for (int i = 0; i < 0 && RandomValues != null && i < RandomValues.Length; i++)
        {
            bytes.AsSpan(0 + i * 1)[0] = RandomValues[i];
        }
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct BuyTicketOutput : ISmartContractOutput<BuyTicketOutput>
{
    public byte ReturnCode { get; init; }

    public static BuyTicketOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new BuyTicketOutput
        {
            ReturnCode = data.Slice(0, 1)[0]
        };
    }
}

// ═══ Procedure: SetPrice (inputType=2) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class SetPricePayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 8;

    public ushort InputType => 2;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public ulong NewPrice { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), NewPrice);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct SetPriceOutput : ISmartContractOutput<SetPriceOutput>
{
    public byte ReturnCode { get; init; }

    public static SetPriceOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new SetPriceOutput
        {
            ReturnCode = data.Slice(0, 1)[0]
        };
    }
}

// ═══ Procedure: SetSchedule (inputType=3) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class SetSchedulePayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 1;

    public ushort InputType => 3;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public byte NewSchedule { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        bytes.AsSpan(0, 1)[0] = NewSchedule;
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct SetScheduleOutput : ISmartContractOutput<SetScheduleOutput>
{
    public byte ReturnCode { get; init; }

    public static SetScheduleOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new SetScheduleOutput
        {
            ReturnCode = data.Slice(0, 1)[0]
        };
    }
}

// ═══ Procedure: SetTargetJackpot (inputType=4) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class SetTargetJackpotPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 8;

    public ushort InputType => 4;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public ulong NewTargetJackpot { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), NewTargetJackpot);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct SetTargetJackpotOutput : ISmartContractOutput<SetTargetJackpotOutput>
{
    public byte ReturnCode { get; init; }

    public static SetTargetJackpotOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new SetTargetJackpotOutput
        {
            ReturnCode = data.Slice(0, 1)[0]
        };
    }
}

// ═══ Procedure: SetDrawHour (inputType=5) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class SetDrawHourPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 1;

    public ushort InputType => 5;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public byte NewDrawHour { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        bytes.AsSpan(0, 1)[0] = NewDrawHour;
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct SetDrawHourOutput : ISmartContractOutput<SetDrawHourOutput>
{
    public byte ReturnCode { get; init; }

    public static SetDrawHourOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new SetDrawHourOutput
        {
            ReturnCode = data.Slice(0, 1)[0]
        };
    }
}
