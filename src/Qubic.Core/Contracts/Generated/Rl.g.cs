// <auto-generated>
// Generated by Qubic.ContractGen from RandomLottery.h.
// Do not edit manually. Re-run the generator after updating deps/qubic-core.
// </auto-generated>

using System.Buffers.Binary;
using Qubic.Core.Contracts;
using Qubic.Core.Payloads;

namespace Qubic.Core.Contracts.Rl;

/// <summary>Rl contract (index 16).</summary>
public static class RlContract
{
    /// <summary>Contract index on the Qubic network.</summary>
    public const int ContractIndex = 16;

    /// <summary>Gets the 32-byte contract public key.</summary>
    public static byte[] GetPublicKey() => QubicContracts.GetContractPublicKey(ContractIndex);

    /// <summary>Read-only query function IDs.</summary>
    public static class Functions
    {
        /// <summary>GetFees (inputType=1).</summary>
        public const uint GetFees = 1;
        /// <summary>GetPlayers (inputType=2).</summary>
        public const uint GetPlayers = 2;
        /// <summary>GetWinners (inputType=3).</summary>
        public const uint GetWinners = 3;
        /// <summary>GetTicketPrice (inputType=4).</summary>
        public const uint GetTicketPrice = 4;
        /// <summary>GetMaxNumberOfPlayers (inputType=5).</summary>
        public const uint GetMaxNumberOfPlayers = 5;
        /// <summary>GetState (inputType=6).</summary>
        public const uint GetState = 6;
        /// <summary>GetBalance (inputType=7).</summary>
        public const uint GetBalance = 7;
        /// <summary>GetNextEpochData (inputType=8).</summary>
        public const uint GetNextEpochData = 8;
        /// <summary>GetDrawHour (inputType=9).</summary>
        public const uint GetDrawHour = 9;
        /// <summary>GetSchedule (inputType=10).</summary>
        public const uint GetSchedule = 10;
    }

    /// <summary>State-mutating procedure IDs.</summary>
    public static class Procedures
    {
        /// <summary>BuyTicket (inputType=1).</summary>
        public const uint BuyTicket = 1;
        /// <summary>SetPrice (inputType=2).</summary>
        public const uint SetPrice = 2;
        /// <summary>SetSchedule (inputType=3).</summary>
        public const uint SetSchedule = 3;
    }
}

// ═══ Function: GetFees (inputType=1) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetFeesInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetFeesOutput : ISmartContractOutput<GetFeesOutput>
{
    public byte TeamFeePercent { get; init; }
    public byte DistributionFeePercent { get; init; }
    public byte WinnerFeePercent { get; init; }
    public byte BurnPercent { get; init; }
    public byte ReturnCode { get; init; }

    public static GetFeesOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetFeesOutput
        {
            TeamFeePercent = data.Slice(0, 1)[0],
            DistributionFeePercent = data.Slice(1, 1)[0],
            WinnerFeePercent = data.Slice(2, 1)[0],
            BurnPercent = data.Slice(3, 1)[0],
            ReturnCode = data.Slice(4, 1)[0]
        };
    }
}

// ═══ Function: GetPlayers (inputType=2) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetPlayersInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetPlayersOutput : ISmartContractOutput<GetPlayersOutput>
{
    public byte[][] Players { get; init; }
    public ulong PlayerCounter { get; init; }
    public byte ReturnCode { get; init; }

    public static GetPlayersOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var players = new byte[0][];
        for (int i = 0; i < 0; i++)
        {
            players[i] = data[(0 + i * 32)..].Slice(0, 32).ToArray();
        }
        return new GetPlayersOutput
        {
            Players = players,
            PlayerCounter = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            ReturnCode = data.Slice(8, 1)[0]
        };
    }
}

// ═══ Function: GetWinners (inputType=3) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetWinnersInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetWinnersOutput : ISmartContractOutput<GetWinnersOutput>
{
    public byte[] Winners { get; init; }
    public ulong WinnersCounter { get; init; }
    public byte ReturnCode { get; init; }

    public static GetWinnersOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetWinnersOutput
        {
            Winners = [] /* unknown struct array WinnerInfo */,
            WinnersCounter = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            ReturnCode = data.Slice(8, 1)[0]
        };
    }
}

// ═══ Function: GetTicketPrice (inputType=4) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetTicketPriceInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetTicketPriceOutput : ISmartContractOutput<GetTicketPriceOutput>
{
    public ulong TicketPrice { get; init; }

    public static GetTicketPriceOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetTicketPriceOutput
        {
            TicketPrice = BinaryPrimitives.ReadUInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Function: GetMaxNumberOfPlayers (inputType=5) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetMaxNumberOfPlayersInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetMaxNumberOfPlayersOutput : ISmartContractOutput<GetMaxNumberOfPlayersOutput>
{
    public ulong NumberOfPlayers { get; init; }

    public static GetMaxNumberOfPlayersOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetMaxNumberOfPlayersOutput
        {
            NumberOfPlayers = BinaryPrimitives.ReadUInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Function: GetState (inputType=6) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetStateInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetStateOutput : ISmartContractOutput<GetStateOutput>
{
    public byte CurrentState { get; init; }

    public static GetStateOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetStateOutput
        {
            CurrentState = data.Slice(0, 1)[0]
        };
    }
}

// ═══ Function: GetBalance (inputType=7) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetBalanceInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetBalanceOutput : ISmartContractOutput<GetBalanceOutput>
{
    public ulong Balance { get; init; }

    public static GetBalanceOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetBalanceOutput
        {
            Balance = BinaryPrimitives.ReadUInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Function: GetNextEpochData (inputType=8) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetNextEpochDataInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetNextEpochDataOutput : ISmartContractOutput<GetNextEpochDataOutput>
{
    public byte[] NextEpochData { get; init; }

    public static GetNextEpochDataOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetNextEpochDataOutput
        {
            NextEpochData = [] /* unknown type NextEpochData */
        };
    }
}

// ═══ Function: GetDrawHour (inputType=9) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetDrawHourInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetDrawHourOutput : ISmartContractOutput<GetDrawHourOutput>
{
    public byte DrawHour { get; init; }

    public static GetDrawHourOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetDrawHourOutput
        {
            DrawHour = data.Slice(0, 1)[0]
        };
    }
}

// ═══ Function: GetSchedule (inputType=10) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetScheduleInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetScheduleOutput : ISmartContractOutput<GetScheduleOutput>
{
    public byte Schedule { get; init; }

    public static GetScheduleOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetScheduleOutput
        {
            Schedule = data.Slice(0, 1)[0]
        };
    }
}

// ═══ Procedure: BuyTicket (inputType=1) ═══

/// <summary>Input for procedure (empty payload).</summary>
public sealed class BuyTicketPayload : ITransactionPayload, ISmartContractInput
{
    public ushort InputType => 1;
    public ushort InputSize => 0;
    public int SerializedSize => 0;
    public byte[] GetPayloadBytes() => [];
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct BuyTicketOutput : ISmartContractOutput<BuyTicketOutput>
{
    public byte ReturnCode { get; init; }

    public static BuyTicketOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new BuyTicketOutput
        {
            ReturnCode = data.Slice(0, 1)[0]
        };
    }
}

// ═══ Procedure: SetPrice (inputType=2) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class SetPricePayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 8;

    public ushort InputType => 2;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public ulong NewPrice { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), NewPrice);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct SetPriceOutput : ISmartContractOutput<SetPriceOutput>
{
    public byte ReturnCode { get; init; }

    public static SetPriceOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new SetPriceOutput
        {
            ReturnCode = data.Slice(0, 1)[0]
        };
    }
}

// ═══ Procedure: SetSchedule (inputType=3) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class SetSchedulePayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 1;

    public ushort InputType => 3;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public byte NewSchedule { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        bytes.AsSpan(0, 1)[0] = NewSchedule;
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct SetScheduleOutput : ISmartContractOutput<SetScheduleOutput>
{
    public byte ReturnCode { get; init; }

    public static SetScheduleOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new SetScheduleOutput
        {
            ReturnCode = data.Slice(0, 1)[0]
        };
    }
}
